<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>域名相关信息搜集</title>
      <link href="2020/12/30/yu-ming-xiang-guan-xin-xi-sou-ji/"/>
      <url>2020/12/30/yu-ming-xiang-guan-xin-xi-sou-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么"></a>域名是什么</h2><p>机器在网络层互通用的是IP，但是纯数字的IP难以记忆，为了方便使用，前辈们创造出了域名这个东西，用一串字符串代替IP地址，方便人们记忆和使用<br>sina.com<br>这就是域名<br><a href="http://www.sina.com/">www.sina.com</a><br>这是完全限定域名，也叫FQDN，那个www是主机名</p><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>但是这东西是要代替IP用的，所以前辈又整了个dns出来，也就是域名解析，把域名转换为对应IP<br><img src="1.jpg" alt="dns解析过程"><br>以普通家庭网为例，上图就是一个对新浪域名sina.com的完整dns解析的过程，pc在解析一个域名时会向dns服务器发出请求，一般pc的dns服务器就是家里的路由器，接下来会由路由器完成解析并返回结果给pc<br>路由器首先会向根域名服务器请求（全球有十三台IPv4根域名服务器，这十三台服务器的地址是所有dns服务器都自带的），根域名服务器并不知道sina.com的地址，但是他会返回com域名服务器的地址，让路由器去com域名服务器上查询，com域名服务器会返回sina.com的域名服务器，最后路由器会在sina.com域名服务器上查到地址并返回给pc<br>pc向他的dns服务器也就是路由器查询称为递归查询，dns服务器从根域名开始查询称为迭代查询</p><h3 id="域名记录种类"><a href="#域名记录种类" class="headerlink" title="域名记录种类"></a>域名记录种类</h3><p>A：主机地址<br>AAAA：IPv6下的主机IP地址<br>CNAME：别名，指向其他主机名，A记录优先级高于CNAME<br>MX：邮件记录，将该域名结尾的邮件指向对应的邮件服务器，记录可以是域名或IP<br>NS：指定子域名的解析服务器，由哪台主机来解析该子域名<br>ptr：由IP反向解析出域名<br>spf：IP反查域名，用于排查垃圾邮件</p><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>kali不自带，apt instal dnsutils安装<br>交互模式</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nslookup进入或者nslookup - 114.114.114.114可以指定dns服务器进入进入交互模式后每输入一个域名就解析一个set type=mx设置参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非交互模式</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">类似pingnslookup -type=mx A B-type=mx 参数（可选）A 域名B 域名服务器（可选）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dig +noall +answer sina.com any @8.8.8.8+noall 不显示所有结果+answer 显示查询结果sina.com 域名any 查询类型@8.8.8.8 域名服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dig -x 1.1.1.1反向查询，ptr记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dig txt chaos VERSION.BIND @ns3.dnsv4.com查询dns服务器bind软件版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>dig +trace sina.com<br>这个命令会从根域名服务器开始进行完整的迭代，干了本来dns服务器干的事，wireshark抓包可以清晰地看见dns的解析过程<br><img src="2.jpg" alt="解析根域名"></p><p>可以看见第一步先解析了跟域名服务器，dns服务器返回了十三台根域名服务器，然后客户端开始解析十三台根域名服务器</p><p><img src="3.jpg" alt="解析com域名服务器"></p><p>然后dig会挑一台根域名服务器去解析，根域名服务器会返回com域名服务器，dig会接着解析com域名服务器</p><p><img src="4.jpg" alt="解析sina.com域名服务器"></p><p>解析完com域名服务器后会再随机挑一台解析sina.com，会得到sina.com的域名解析服务器</p><p><img src="5.jpg" alt="解析sina.com"></p><p>最后向新浪的域名服务器请求得到解析结果</p><h3 id="域传送"><a href="#域传送" class="headerlink" title="域传送"></a>域传送</h3><p>dns服务器之间同步记录会相互发送全部的dns记录，可以尝试dns服务器设置是否严格，能否请求到dns记录<br>查询dns记录使用udp53端口，域传送使用tcp53端口</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dig @ns1.example.com example.com axfrhost -T -l sina.com @ns2.sina.com向域名服务器请求域传送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>搜索引擎其实就是提前爬取了全网的数据存在数据库里，在你搜索的时候直接从数据库里找数据，google，bing主要是web爬取，shodan和fofa会注重banner，地址，IP，指纹等，这些搜索引擎都有专门的搜索语法来精确搜索我们需要的结果，也都有api用于程序的调用</p><h3 id="www-shodan-io"><a href="#www-shodan-io" class="headerlink" title="www.shodan.io"></a><a href="http://www.shodan.io/">www.shodan.io</a></h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{    "data": "Moxa Nport Device            Status: Authentication disabled            Name: NP5232I_4728            MAC: 00:90:e8:47:10:2d",    "ip_str": "46.252.132.235",    "port": 4800,    "org": "Starhub Mobile",    "location": {        "country_code": "SG"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shodan会爬取全网的banner信息并保存在数据库中，按照官方的文档应该是以这样的jason格式存储的，我们的搜索会默认在data中匹配，要匹配别的部分就需要用关键字，注意冒号要用英文冒号，关键字与值之间没有空格<br>比如要搜索192.168.1.0这个c段<br>net:192.168.1.0/24<br>只要国内的<br>country:CN<br>多指令并列搜索<br>net:192.168.1.1/24 country:CN city:beijing</p><p>官方给出的过滤器列表</p><p><img src="6.png" alt="过滤器"></p><h3 id="fofa-so"><a href="#fofa-so" class="headerlink" title="fofa.so"></a>fofa.so</h3><p>也是爬取全网的搜索引擎，会分析web页面，cms指纹，应用版本，设备类型等<br>帮助文档<a href="https://fofa.so/help">https://fofa.so/help</a><br>语法<br>采用关键字和值的方式<br>title=”abc” 从标题中搜索abc<br>可以采用括号等符号<br>&amp;&amp; 逻辑与<br>|| 逻辑或<br>= 包含<br>!= 不包含</p><h3 id="Google-hacking"><a href="#Google-hacking" class="headerlink" title="Google hacking"></a>Google hacking</h3><p>特性<br>所有符号皆采用英文符号，操作符与关键字之间无空格<br>英文符号无法成为关键字<br>对英文大小写不敏感<br>关键字带空格必须加英文引号<br>可以用通配符，inurl:”<a href="http://www.ba*u.com&quot;/">www.ba*u.com"</a><br>语法<br>+代表逻辑与，可以省略，如：易筋经 +吸星大法，等同于：易筋经 吸星大法<br>-代表逻辑非，如：易筋经 -吸星大法，搜索易筋经但是不要吸星大法<br>OR代表逻辑或，如：易筋经 OR 吸星大法，搜索有其中任意一项的网站<br>    “+”和“-”的作用有的时候是相同的，都是为了缩小搜索结果的范围，提高查询结果命中率。<br>    例：查阅天龙八部具体是哪八部。<br>    分析：如果光用“天龙八部”做关键字，搜索结果有26,500项，而且排前列的主要与金庸的小说《天龙八部》相关，很难找到所需要的资讯。可以用两个方法减少无关结果。<br>    1，如果你知道八部中的某一部，比如阿修罗，增加“阿修罗”关键字，搜索结果就只有995项，可以直接找到全部八部，“天龙八部 阿修罗”。<br>    2，如果你不知道八部中的任何一部，但知道这与佛教相关，可以排除与金庸小说相关的记录，查询结果为1,010项，可以迅速找到需要的资料，“天龙八部 佛教 -金庸”。<br>site：限定域名<br>inurl：在url中<br>allinurl：全部在url中<br>intitle：在标题中<br>allintitle：全在标题中<br>intext：在内容中<br>alliintext：全在内容中<br>filetype：文件类型<br>cache：Google保存的网页快照<br>related：类似网页</p><h3 id="theHarvester"><a href="#theHarvester" class="headerlink" title="theHarvester"></a>theHarvester</h3><p>调用搜索引擎自动搜集邮箱和子域名的工具<br>-d 目标域名<br>-l 搜索请求数量限制<br>-b 搜索引擎，会调用国外的服务器，可能需要翻墙，搜索量过大会被搜索引擎屏蔽</p><h3 id="metagoofil"><a href="#metagoofil" class="headerlink" title="metagoofil"></a>metagoofil</h3><p>利用Google自动搜索域名下的特定类型文件的工具，还可以可以自动下载文件</p><h3 id="maltego"><a href="#maltego" class="headerlink" title="maltego"></a>maltego</h3><p>信息搜集的商业图形化工具，可以自动搜集信息，图形化的显示出细节关系等</p>]]></content>
      
      
      <categories>
          
          <category> 信息搜集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息搜集 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wpa破解</title>
      <link href="2020/12/07/wpa-po-jie/"/>
      <url>2020/12/07/wpa-po-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>wpa协议的安全性相较wep和wps来说是比较高的，到现在为止没有发现能从协议层破解密码的严重漏洞，前几年公布了krack攻击，可以解密监听数据，但也跟密码没关系，对于获取密码最常用的法子还是爆破，所以WiFi字典一般都不会小</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>wpa认证有一个四步握手的过程，我觉得下图比较形象的说明了这四步握手<br><img src="1.png" alt="四步握手"><br>STA是客户端（station），AP是就是无线接入点（access point），开始前还有一步，由于正常情况下双方都知道密钥，他们会先各自由密钥生成相同的PMK，这个PMK是起点，一共需要五个要素生成最终的凭证</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>AP先向STA发一个包，其中包含一个随机数ANONCE</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>STA接到随机数后会自己生成第二个随机数SNONCE，同时AP的包里会有AP的MAC地址，至此五个要素就起了，分别是PMK，ANONCE，SNONCE，AP的MAC，STA的MAC，STA会用这五个要素生成PTK，并计算校验值MIC，然后会将SNONCE和MIC一起发给AP，注意，PMK和PTK自始至终都不会进行传输，传输的是MIC</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>AP接到包后也就凑齐了五要素，计算出了PTK，也就可以算出MIC，对比STA发的MIC，如果一样就是通过了认证，接着发送数据包让STA安装组密钥</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>STA发送确认包</p><h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><p>看完这四步我们会发现认证主要在前两部，几个要素除了PMK在前两步都出现了，其实甚至可以不用AP，有的骚思路直接伪造ap，随机数我们可以产生，MAC也可以伪造，完全可以通过前两步套出所有要素。回到破解，我们拿到这几个要素后我们就有了验证对错的MIC和计算的所有要素，只有PMK我们没有，而PMK由密钥和essid计算产生，所以我们就可以用字典进行爆破，用字典的密钥计算出PMK，再计算出PTK,计算出MIC，就可以知到密钥的对错</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>实际操作其实很简单，由原理可以看出其实就抓握手包和爆破两步</p><h3 id="准备网卡"><a href="#准备网卡" class="headerlink" title="准备网卡"></a>准备网卡</h3><p>网卡接入虚拟机，airmon-ng命令准备环境</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">airmon-ng check kill杀掉可能有影响的进程airmon-ng start wlan0把网卡调至monitor模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">airodump-ng -c 11 -w test -d AA:AA:AA:AA:AA:AA wlan0mon-c 指定信道，调至目标信道监听效果会更好，不然会进行轮询-w 指定保存的文件名，会保存多个文件-d 目标的bssid，就是AP的MAC地址wlan0mon 网卡，有的无线网卡用airmon-ng改成monitor会改名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抓到包后右上角会有提示<br><img src="2.png" alt="握手包"><br>这些test开头的都是抓到的文件<br><img src="3.png" alt="抓到的文件"><br>这里有一个问题就是握手包是连接的时候才会有的，那没人连的时候就抓不到了，这时候就要打断已有连接，让他们重连一下，抓取握手包</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">direplay-ng -0 1 -a ap的mac -c 客户端mac wlan0mon-0 会发送断开连接的包，让STA和AP断开连接，1是次数，可以随意指定，感觉不稳定可以多发几个包，0会一直发包-a ap的mac -c 客户端mac，不加-c参数会广播给所有sta，但是有的客户端可能会拒绝广播的攻击wlan0mon 指定网卡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">aircrack-ng -w 1.txt test.cap-w 指定字典test.cap 抓到的流量文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>破解成功结果，我用的是一个三十万的小字典，把密码加在了最后，可以看出速度是一秒五千，而且不是顺序的，我把密码加在了最后而字典跑了五万就把最后一个拿去跑了，说明他不是严格按顺序跑的，如果跑大字典就可以发现他只是大概按顺序跑<br><img src="4.png" alt="破解结果"></p><h2 id="加速破解"><a href="#加速破解" class="headerlink" title="加速破解"></a>加速破解</h2><p>从之前的破解可以看出，这东西是个挺慢的事，四五千每秒不慢，但是字典动不动百万千万就扛不住了，所以需要加快。<br>从原理上看我们要算PMK，PTK，MIC，而PMK我们可以提前算，只要知道密钥和wifi名就行，而这恰巧是计算量最大的一步，所以我们可以提前把字典算成彩虹表，这样实际破解的时候速度就会加快不少。</p><h3 id="airolib"><a href="#airolib" class="headerlink" title="airolib"></a>airolib</h3><p>这是aircrack套件的一部分，会维护一个数据库，算出彩虹表后会存在数据库里，aircrack可以直接从数据库里读取<br>计算PMK</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">echo ap的essid &gt; essid.txtairolib-ng db --import essid essid.txt创建数据库，导入essidairolib-ng db --import passwd 字典导入字典，自动去除不符合格式的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">airolib-ng db --stats查看数据库状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">airolib-ng db --batch生成pmk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行破解</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">aircrack-ng -r db test.cap用数据库中的哈希表进行破解-r 使用数据库test.cap 破解文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cowpatty"><a href="#cowpatty" class="headerlink" title="cowpatty"></a>cowpatty</h3><p>这是一个单独的wpa爆破工具，可以生成彩虹表和wpa爆破<br>使用密码字典爆破</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cowpatty r wpa.cap -f password.lst -s essid-r 流量文件-f 字典文件-s essid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>彩虹表爆破</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">genpmk -f password.lst -d 生成的hash文件 -s essid生成彩虹表-f 字典-s essid-d 生成的彩虹表文件名cowpatty -r wpa.cap -d 生成的hash文件 -s essid-r 流量文件-d 彩虹表-s essid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pyrit"><a href="#pyrit" class="headerlink" title="pyrit"></a>pyrit</h3><p>该工具特殊的地方在于它能调用GPU算力来算彩虹表，别的工具只能用cpu，但是使用条件比较苛刻，他要用显卡，而虚拟机装显卡驱动特别麻烦，要用的话基本得本机装kali，而且kali也不自带这个工具</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">可以自己抓取数据包，不用airodump-ngpyrit -r wlan0mon -o wpa.cap sriplive抓包保存为wpa.cap，只保留握手包pyrit -r wpa.cap analyze分析数据包pyrit -r wpa.cap -o wpapyrit.cap strip读取airodump抓的包，转换成pyrit格式，并去除其他包只保留握手<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">用密码直接破解pyrit  -r wpa.cap -I pass.lst -b ap的mac attack_passthrough<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">彩虹表模式破解  默认使用基于文件的数据库，支持连接sql数据库，将计算的pmk存  数据库  查看默认数据库状态  pyrit eval  导入密码字典（自动剔除不合规密码）  pyrit -I password.lst import_passwords  指定essid  pyrit -e essid create_essid  计算pmk，发挥gpu算力  pyrit batch  破解密码  pyrit -r wpa.cap -b ap的mac attack_db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流氓ap及用法</title>
      <link href="2020/12/07/liu-mang-ap-ji-yong-fa/"/>
      <url>2020/12/07/liu-mang-ap-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>流氓ap（rogue ap），也叫邪恶双子星（evil twin），老外起名字就是nb。原理非常简单，你有一台可以上网的设备，然后你伪造一个ap，让人们连接你的ap，让流量通过伪造的ap再通过你设备上网，这样你就实现了一个中间人攻击，可以监听流量，甚至可以劫持篡改。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先，把网卡导入虚拟机，先用airmon-ng命令关闭可能会影响攻击的进程<br><img src="1.png" alt="airmon-ng命令"><br>用airbase-ng命令开启伪造ap，–essid参数是要伪造的ap名，-c是信道，如果要伪造mac地址的话可以跟上-a加mac地址，该命令会自动增加一块网卡at0，接下来需要把这块网卡和上网的网卡桥接<br><img src="2.png" alt="airbase-ng命令"><br>桥接网卡需要用到bridge-utils工具，kali默认是不自带的，需要用apt安装一下</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">apt install bridge-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用brctl这个命令，先创建一个网桥，再添加桥接网卡</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">brctl addbr br添加名叫br的网桥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">brctl addif br eth0给网桥添加网卡，eth0是连接网络的网卡brctl addif br at0at0是ap自动生成的网卡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来把两张网卡的IP设为零，也就是没有IP，这里有一点要注意，设为零之前先记住eth0的IP，之后需要给网桥用</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ifconfig eth0 0.0.0.0 upifconfig at0 0.0.0.0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置网桥IP为原有线网卡eth0的IP,假设是192.168.1.111</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ifconfig br 192.168.1.111 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改完网卡后ifconfig查看应该是这样的<br><img src="3.png" alt="网卡状态"><br>添加网关，把网关设为路由器地址，不然不能上网</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动IP转发,这个文件直接vi修改是没有权限的，0代表关闭，1代表开启</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">echo 1 &gt; /proc/sys/net/ipv4/ip_forward<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候应该是能ping通网关能上网的<br><img src="4.png" alt="ping网关"><br>这个时候再用手机连开的wifi应该就能上网了，IP是由路由器分配的，如果路由器有查看连接设备的功能的话，在路由器的管理界面应该可以查看到这个设备<br><img src="5.png" alt="ipad连接"><br>也可以把这些命令写成一个shell脚本，不用每次一条条命令敲<br><img src="10.png" alt="脚本"></p><h2 id="监听流量"><a href="#监听流量" class="headerlink" title="监听流量"></a>监听流量</h2><p>打开wireshark，可以在接口列表看见我们创建的网桥<br><img src="6.png" alt="接口列表"><br>监听网卡，我们就能看见设备的明文流量，我的移动设备分到的IP是192.168.1.114<br><img src="7.png" alt="流量"><br>添加显示筛选器就可以看见设备所有的流量，实战中就可以读取其中的敏感信息，登录凭证等<br><img src="8.png" alt="流量"></p><h2 id="dns劫持"><a href="#dns劫持" class="headerlink" title="dns劫持"></a>dns劫持</h2><p>劫持需要用到的工具是dnsspoof，这个工具包含于dsniff套件中，kali默认也不自带，需要用apt安装<br><img src="9.png" alt="安装dsniff"><br>需要写一个文件，把要欺骗的域名和目的IP用类似hosts文件的格式写在文件里<br><img src="11.png" alt="欺骗的文件"><br>dnsspoof命令需要两个参数，-i指定网卡，-f指定文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dnsspoof -i wlan0mon -f 1.hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时再在手机上访问nbbs.top就会被重定向到网关</p>]]></content>
      
      
      <categories>
          
          <category> WiFi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JDBC的时候发现的一点小意外</title>
      <link href="2020/12/04/shi-yong-jdbc-de-shi-hou-fa-xian-de-yi-dian-xiao-yi-wai/"/>
      <url>2020/12/04/shi-yong-jdbc-de-shi-hou-fa-xian-de-yi-dian-xiao-yi-wai/</url>
      
        <content type="html"><![CDATA[<p>根据JDBC规范Java在连接数据库的时候需要导入对应数据库驱动，最近在写jsp的时候发现了一件很神奇的事，我用的是idea，正常导入jar包驱动的时候是File-&gt;project structure-&gt;modules-&gt;dependencies，也就是下面这个位置<br><img src="1.png" alt="1"><br>但是一跑起来在class.forname注册驱动的时候就出异常，找不到驱动包，为了验证我还特地新建了一个命令行的项目来测试数据库连接代码，代码没问题，导入jar包也没问题，结果能正常出，但是一到jsp的项目里就不好使，我又新建了一个新的jsp项目，也找不到驱动包。<br>网上也没找到一样的情况，最后试出了解决办法，jsp在引入jar包的时候引入上层的文件夹而不是直接导入jar包，如下图所示<br><img src="2.png" alt="2"><br>我估计可能是环境哪没配置对或者是我没遵循什么规范，还是太菜了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的奇技淫巧</title>
      <link href="2020/11/29/git-de-qi-ji-yin-qiao/"/>
      <url>2020/11/29/git-de-qi-ji-yin-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的奇技淫巧-see-no-evil"><a href="#Git的奇技淫巧-see-no-evil" class="headerlink" title="Git的奇技淫巧:see_no_evil:"></a>Git的奇技淫巧<span class="github-emoji"><span>🙈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f648.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h1><blockquote><p>Git常用命令集合，Fork于<a href="https://github.com/git-tips/tips">tips</a>项目</p></blockquote><p>引用自<a href="http://www.cnblogs.com/xueweihan/">削微寒的博客</a><br>博主是<a href="https://github.com/521xueweihan/HelloGitHub">hello GitHub项目</a>的主持者,每月会推荐很多好玩的开源项目</p><p>Git是一个“分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过“回撤”这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用“回撤”是找不回来的。而“版本管理工具”能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p><p>下面的内容就是列举了常用的Git命令和一些小技巧，可以通过”页面内查找”的方式进行快速查询：<code>Ctrl/Command+f</code>。</p><h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过Git，可以学习<a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git小白教程</a>入门</em></p><ol><li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li><li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li><li>统一概念：<ul><li>工作区：改动（增删文件和内容）</li><li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了‘暂存区’</li><li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。</li><li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了‘远程仓库’（GitHub等)</li><li>commit-id：输出命令：<code>git log</code>，最上面那行<code>commit xxxxxx</code>，后面的字符串就是commit-id</li></ul></li><li>如果喜欢这个项目，欢迎Star、提交Pr、<a href="https://github.com/521xueweihan/git-tips/issues">反馈问题</a>😊</li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%B1%95%E7%A4%BA%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF">展示帮助信息</a></li><li><a href="#%E5%9B%9E%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81">回到远程仓库的状态</a></li><li><a href="#%E9%87%8D%E8%AE%BE%E7%AC%AC%E4%B8%80%E4%B8%AAcommit">重设第一个commit</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E4%B8%8D%E5%90%8C">展示工作区和暂存区的不同</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C">展示暂存区和最近版本的不同</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C">展示暂存区、工作区和最近版本的不同</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF">快速切换分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E5%90%88%E5%B9%B6%E5%88%B0master%E7%9A%84%E5%88%86%E6%94%AF">删除已经合并到master的分支</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%83%85%E5%86%B5">展示本地分支关联远程仓库的情况</a></li><li><a href="#%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">关联远程分支</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">列出所有远程分支</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">列出本地和远程分支</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">创建并切换到本地分支</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">创建并切换到远程分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">删除本地分支</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">重命名本地分支</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE">查看标签</a></li><li><a href="#%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE">本地创建标签</a></li><li><a href="#%E6%8E%A8%E9%80%81%E6%A0%87%E7%AD%BE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送标签到远程仓库</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%A0%87%E7%AD%BE">删除本地标签</a></li><li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE">删除远程标签</a></li><li><a href="#%E5%88%87%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA%E6%A0%87%E7%AD%BE">切回到某个标签</a></li><li><a href="#%E6%94%BE%E5%BC%83%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E4%BF%AE%E6%94%B9">放弃工作区的修改</a></li><li><a href="#%E6%81%A2%E5%A4%8D%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6">恢复删除的文件</a></li><li><a href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%80%E4%B8%AAcommit%E7%9A%84%E7%8A%B6%E6%80%81%E5%B9%B6%E9%87%8D%E6%96%B0%E5%A2%9E%E6%B7%BB%E4%B8%80%E4%B8%AAcommit">回到某一个commit的状态，并重新增添一个commit</a></li><li><a href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E7%8A%B6%E6%80%81%E5%B9%B6%E5%88%A0%E9%99%A4%E5%90%8E%E9%9D%A2%E7%9A%84commit">回到某个commit的状态，并删除后面的commit</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%B8%80%E4%B8%AAcommit%E7%9A%84%E6%8F%8F%E8%BF%B0">修改上一个commit的描述</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bcommit%E5%8E%86%E5%8F%B2">查看commit历史</a></li><li><a href="#%E6%98%BE%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C%E8%BF%87git%E5%91%BD%E4%BB%A4">显示本地执行过git命令</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E4%BD%9C%E8%80%85%E5%90%8D">修改作者名</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84url">修改远程仓库的url</a></li><li><a href="#%E5%A2%9E%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">增加远程仓库</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">列出所有远程仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E4%B8%A4%E4%B8%AA%E6%98%9F%E6%9C%9F%E5%86%85%E7%9A%84%E6%94%B9%E5%8A%A8">查看两个星期内的改动</a></li><li><a href="#%E6%8A%8AA%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAcommit%E6%94%BE%E5%88%B0B%E5%88%86%E6%94%AF%E4%B8%8A">把A分支的某一个commit，放到B分支上</a></li><li><a href="#%E7%BB%99git%E5%91%BD%E4%BB%A4%E8%B5%B7%E5%88%AB%E5%90%8D">给git命令起别名</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%BD%93%E5%89%8D%E7%9A%84%E4%BF%AE%E6%94%B9%E4%BD%86%E4%B8%8D%E7%94%A8%E6%8F%90%E4%BA%A4commit">存储当前的修改，但不用提交commit</a></li><li><a href="#%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81%E5%8C%85%E6%8B%ACuntracked%E7%9A%84%E6%96%87%E4%BB%B6">保存当前状态，包括untracked的文件</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89stashes">展示所有stashes</a></li><li><a href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AAstash%E7%9A%84%E7%8A%B6%E6%80%81">回到某个stash的状态</a></li><li><a href="#%E5%9B%9E%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAstash%E7%9A%84%E7%8A%B6%E6%80%81%E5%B9%B6%E5%88%A0%E9%99%A4%E8%BF%99%E4%B8%AAstash">回到最后一个stash的状态，并删除这个stash</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84stash">删除所有的stash</a></li><li><a href="#%E4%BB%8Estash%E4%B8%AD%E6%8B%BF%E5%87%BA%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">从stash中拿出某个文件的修改</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89tracked%E7%9A%84%E6%96%87%E4%BB%B6">展示所有tracked的文件</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89untracked%E7%9A%84%E6%96%87%E4%BB%B6">展示所有untracked的文件</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6">展示所有忽略的文件</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4untracked%E7%9A%84%E6%96%87%E4%BB%B6">强制删除untracked的文件</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4untracked%E7%9A%84%E7%9B%AE%E5%BD%95">强制删除untracked的目录</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E7%AE%80%E5%8C%96%E7%9A%84commit%E5%8E%86%E5%8F%B2">展示简化的commit历史</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%98%AF%E8%B0%81%E5%86%99%E7%9A%84">查看某段代码是谁写的</a></li><li><a href="#%E6%8A%8A%E6%9F%90%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%88%B0%E5%AF%BC%E5%87%BA%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6">把某一个分支到导出成一个文件</a></li><li><a href="#%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%88%86%E6%94%AF">从包中导入分支</a></li><li><a href="#%E6%89%A7%E8%A1%8Crebase%E4%B9%8B%E5%89%8D%E8%87%AA%E5%8A%A8stash">执行rebase之前自动stash</a></li><li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%A0%B9%E6%8D%AEID%E6%8B%89%E4%B8%8B%E6%9F%90%E4%B8%80%E7%8A%B6%E6%80%81-%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">从远程仓库根据ID，拉下某一状态，到本地分支</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E5%B1%95%E7%A4%BA%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E4%BF%AE%E6%94%B9">详细展示一行中的修改</a></li><li><a href="#%E6%B8%85%E9%99%A4gitignore%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6">清除<code>.gitignore</code>文件中记录的文件</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89alias%E5%92%8Cconfigs">展示所有alias和configs</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6">展示忽略的文件</a></li><li><a href="#commit%E5%8E%86%E5%8F%B2%E4%B8%AD%E6%98%BE%E7%A4%BABranch1%E6%9C%89%E7%9A%84%E4%BD%86%E6%98%AFBranch2%E6%B2%A1%E6%9C%89commit">commit历史中显示Branch1有的，但是Branch2没有commit</a></li><li><a href="#%E5%9C%A8commit-log%E4%B8%AD%E6%98%BE%E7%A4%BAGPG%E7%AD%BE%E5%90%8D">在commit log中显示GPG签名</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE">删除全局设置</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF%E4%B8%8A%E5%90%8C%E6%97%B6%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95commit">新建并切换到新分支上，同时这个分支没有任何commit</a></li><li><a href="#%E5%B1%95%E7%A4%BA%E4%BB%BB%E6%84%8F%E5%88%86%E6%94%AF%E6%9F%90%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9">展示任意分支某一文件的内容</a></li><li><a href="#clone%E4%B8%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8D%95%E4%B8%80%E5%88%86%E6%94%AF">clone下来指定的单一分支</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%B9%E5%8A%A8">忽略某个文件的改动</a></li><li><a href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E5%8F%98%E5%8C%96">忽略文件的权限变化</a></li><li><a href="#%E4%BB%A5%E6%9C%80%E5%90%8E%E6%8F%90%E4%BA%A4%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89Git%E5%88%86%E6%94%AF">以最后提交的顺序列出所有Git分支</a></li><li><a href="#%E5%9C%A8commit-log%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">在commit log中查找相关内容</a></li><li><a href="#%E6%8A%8A%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%8C%87%E5%AE%9Afile%E6%94%BE%E5%88%B0%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%AD">把暂存区的指定file放到工作区中</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81">强制推送</a></li><li><a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a></li></ul><h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git help -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。  </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git fetch --all &amp;&amp; git reset --hard origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重设第一个commit"><a href="#重设第一个commit" class="headerlink" title="重设第一个commit"></a>重设第一个commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的commit</strong>，这样就可以重新提交第一个commit了</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git update-ref -d HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的different(不同)。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以展示本地仓库中任意两个commit之间的文件变动：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff &lt;commit-id&gt; &lt;commit-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本(commit)的different(不同)。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff --cached<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本(commit)的different(不同)。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch --merged master | grep -v '^\*\|  master' | xargs -n 1 git branch -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code>就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -u origin/mybranch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者在push时加上<code>-u</code>参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push origin/mybranch -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r参数相当于：remote</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout -b &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -d &lt;local-branchname&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push origin --delete &lt;remote-branchname&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者  </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push origin :&lt;remote-branchname&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git branch -m &lt;new-branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><pre class="line-numbers language-none"><code class="language-none">git tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>展示当前分支的最近的tag</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git describe --tags --abbrev=0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git tag &lt;version-number&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认tag是打在最近的一次commit上，如果需要指定commit打tag：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ git tag -a &lt;version-number&gt; -m "v1.0 发布(描述)" &lt;commit-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push origin &lt;local-version-number&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一次性推送所有标签，同步到远程仓库：</p><pre class="line-numbers language-none"><code class="language-none">git push origin --tags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git tag -d &lt;tag-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push origin :refs/tags/&lt;tag-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout -b branch_name tag_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout &lt;file-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>放弃所有修改：  </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commitgit checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="回到某一个commit的状态，并重新增添一个commit"><a href="#回到某一个commit的状态，并重新增添一个commit" class="headerlink" title="回到某一个commit的状态，并重新增添一个commit"></a>回到某一个commit的状态，并重新增添一个commit</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git revert &lt;commit-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和revert的区别：reset命令会抹去某个commit id之后的所有commit</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset &lt;commit-id&gt;  #默认就是-mixed参数。git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可 &nbsp; git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改上一个commit的描述"><a href="#修改上一个commit的描述" class="headerlink" title="修改上一个commit的描述"></a>修改上一个commit的描述</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看commit历史"><a href="#查看commit历史" class="headerlink" title="查看commit历史"></a>查看commit历史</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame的意思为‘责怪’，你懂的。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git blame &lt;file-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="显示本地执行过git命令"><a href="#显示本地执行过git命令" class="headerlink" title="显示本地执行过git命令"></a>显示本地执行过git命令</h2><p>就像shell的history一样</p><pre class="line-numbers language-none"><code class="language-none">git reflog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git commit --amend --author='Author Name &lt;email@address.com&gt;'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote set-url origin &lt;URL&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote add origin &lt;remote-url&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git whatchanged --since='2 weeks ago'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="把A分支的某一个commit，放到B分支上"><a href="#把A分支的某一个commit，放到B分支上" class="headerlink" title="把A分支的某一个commit，放到B分支上"></a>把A分支的某一个commit，放到B分支上</h2><p>这个过程需要<code>cherry-pick</code>命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928">参考</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h2><p>简化命令</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --global alias.st status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储当前的修改，但不用提交commit"><a href="#存储当前的修改，但不用提交commit" class="headerlink" title="存储当前的修改，但不用提交commit"></a>存储当前的修改，但不用提交commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000">廖雪峰老师的git教程</a></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="保存当前状态，包括untracked的文件"><a href="#保存当前状态，包括untracked的文件" class="headerlink" title="保存当前状态，包括untracked的文件"></a>保存当前状态，包括untracked的文件</h2><p>untracked文件：新建的文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash -u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示所有stashes"><a href="#展示所有stashes" class="headerlink" title="展示所有stashes"></a>展示所有stashes</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="回到某个stash的状态"><a href="#回到某个stash的状态" class="headerlink" title="回到某个stash的状态"></a>回到某个stash的状态</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash apply &lt;stash@{n}&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="回到最后一个stash的状态，并删除这个stash"><a href="#回到最后一个stash的状态，并删除这个stash" class="headerlink" title="回到最后一个stash的状态，并删除这个stash"></a>回到最后一个stash的状态，并删除这个stash</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除所有的stash"><a href="#删除所有的stash" class="headerlink" title="删除所有的stash"></a>删除所有的stash</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git stash clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从stash中拿出某个文件的修改"><a href="#从stash中拿出某个文件的修改" class="headerlink" title="从stash中拿出某个文件的修改"></a>从stash中拿出某个文件的修改</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示所有tracked的文件"><a href="#展示所有tracked的文件" class="headerlink" title="展示所有tracked的文件"></a>展示所有tracked的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git ls-files -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示所有untracked的文件"><a href="#展示所有untracked的文件" class="headerlink" title="展示所有untracked的文件"></a>展示所有untracked的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git ls-files --others<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git ls-files --others -i --exclude-standard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="强制删除untracked的文件"><a href="#强制删除untracked的文件" class="headerlink" title="强制删除untracked的文件"></a>强制删除untracked的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。<code>clean</code>命令，<strong>注意两点</strong>：  </p><ol><li>clean后，删除的文件无法找回</li><li>不会影响tracked的文件的改动，只会删除untracked的文件</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clean &lt;file-name&gt; -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="强制删除untracked的目录"><a href="#强制删除untracked的目录" class="headerlink" title="强制删除untracked的目录"></a>强制删除untracked的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除untracked的文件。详情见上一条</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clean &lt;directory-name&gt; -df<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示简化的commit历史"><a href="#展示简化的commit历史" class="headerlink" title="展示简化的commit历史"></a>展示简化的commit历史</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git log --pretty=oneline --graph --decorate --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git bundle create &lt;file&gt; &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面<code>git bundle create</code>命令导出的内容</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="执行rebase之前自动stash"><a href="#执行rebase之前自动stash" class="headerlink" title="执行rebase之前自动stash"></a>执行rebase之前自动stash</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git rebase --autostash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从远程仓库根据ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据ID，拉下某一状态，到本地分支"></a>从远程仓库根据ID，拉下某一状态，到本地分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git diff --word-diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="清除gitignore文件中记录的文件"><a href="#清除gitignore文件中记录的文件" class="headerlink" title="清除gitignore文件中记录的文件"></a>清除gitignore文件中记录的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clean -X -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示所有alias和configs"><a href="#展示所有alias和configs" class="headerlink" title="展示所有alias和configs"></a>展示所有alias和configs</h2><p><strong>注意：</strong> config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config --local --list (当前目录)git config --global --list (全局)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git status --ignored<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="commit历史中显示Branch1有的，但是Branch2没有commit"><a href="#commit历史中显示Branch1有的，但是Branch2没有commit" class="headerlink" title="commit历史中显示Branch1有的，但是Branch2没有commit"></a>commit历史中显示Branch1有的，但是Branch2没有commit</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git log Branch1 ^Branch2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="在commit-log中显示GPG签名"><a href="#在commit-log中显示GPG签名" class="headerlink" title="在commit log中显示GPG签名"></a>在commit log中显示GPG签名</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git log --show-signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config --global --unset &lt;entry-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="新建并切换到新分支上，同时这个分支没有任何commit"><a href="#新建并切换到新分支上，同时这个分支没有任何commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何commit"></a>新建并切换到新分支上，同时这个分支没有任何commit</h2><p>相当于保存修改，但是重写commit历史  </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git checkout --orphan &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git show &lt;branch-name&gt;:&lt;file-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="clone下来指定的单一分支"><a href="#clone下来指定的单一分支" class="headerlink" title="clone下来指定的单一分支"></a>clone下来指定的单一分支</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p><pre class="line-numbers language-none"><code class="language-none">git update-index --assume-unchanged path/to/file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>恢复 track 指定文件的改动</p><pre class="line-numbers language-none"><code class="language-none">git update-index --no-assume-unchanged path/to/file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config core.fileMode false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="以最后提交的顺序列出所有Git分支"><a href="#以最后提交的顺序列出所有Git分支" class="headerlink" title="以最后提交的顺序列出所有Git分支"></a>以最后提交的顺序列出所有Git分支</h2><p>最新的放在最上面   </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="在commit-log中查找相关内容"><a href="#在commit-log中查找相关内容" class="headerlink" title="在commit log中查找相关内容"></a>在commit log中查找相关内容</h2><p>通过grep查找，given-text：所需要查找的字段</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git log --all --grep='&lt;given-text&gt;'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h2><p>不添加参数，默认是-mixed</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git reset &lt;file-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git push -f &lt;remote-name&gt; &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令备忘录</title>
      <link href="2020/11/28/linux-ming-ling-bei-wang-lu/"/>
      <url>2020/11/28/linux-ming-ling-bei-wang-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>man command<br>查看命令相关用户手册</p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>init 0 关机<br>init 1 单用户模式<br>init 2 多用户模式，没有nfs，不联网，其他和3相同<br>init 3 完全多用户模式<br>init 4 没有启用<br>init 5 图形化界面<br>init 6 重启</p><p>在CentOS系统下/etc/inittab可以设置默认init</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>列出文件和目录<br>-a 显示隐藏文件<br>-l 显示详细信息<br>-R 显示子目录<br>-h 带单位显示文件大小</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>直观的显示多级目录</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>cat example 查看example文件内容<br>-n 带行号<br>-b 带行号，但是跳过空白行</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>more example查看文件example<br>一页显示不下会显示进度<br>方向键和空格按行滚动<br>page up/down翻页<br>斜杠/搜索，n下一个匹配的字符，类似于vim<br>q 退出</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less example查看文件example<br>类似more，支持更多特性</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>head example 显示文件前十行<br>head -6 example 显示文件前六行</p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>tail example 显示文件最后十行<br>tail -6 example 显示文件最后六行<br>tail -f example 显示文件最后一行，实时更新</p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出<br>-b 剪切字节<br>    -n ：不分割多个字节的字符，如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除。<br>    cut -b 3 file<br>    cut -b 1-2,3 file<br>    cut -b -3,3- file<br>-c 字符<br>    和-b一样<br>-f 域<br>    -d 分隔符（默认制表符），空格-d ‘ ‘<br>    cat /etc/passwd|head -n 5|cut -d : -f 1,3-5<br>    root:0:0:root<br>    bin:1:1:bin<br>    daemon:2:2:daemon<br>    adm:3:4:adm<br>    lp:4:7:lp</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>以默认的方式将文本文件的第一列以ASCII 码的次序排列，并将结果输出到标准输出<br>-b 忽略每行前面开始出的空格字符。<br>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>-f 排序时，将小写字母视为大写字母。<br>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。<br>-n 依照数值的大小排序。<br>-u 意味着是唯一的(unique)，输出的结果是去完重了的。<br>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。<br>-r 以相反的顺序来排序。</p><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>去除重复的行，重复的行不相邻不起作用，所以sort先排序<br>uniq file1 file2<br>file1 输入文件<br>file2 输出文件，不指定就输出到标准输出<br>-c 去重后在行首显示重复次数<br>-d 仅显示重复的行<br>-u 显示只出现一次的行</p><h2 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h2><p>seq 1 5<br>1 2 3 4 5<br>产生一到十之间的整数<br>-s 指定字符串分隔数字<br>-w 在列前加0使其宽度相同</p><h2 id="Tr"><a href="#Tr" class="headerlink" title="Tr"></a>Tr</h2><p>tr 命令用于转换或删除文件中的字符。<br>从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备<br>tr -c -d 字符集1 字符集2<br>-c：反选设定字符。也就是符合字符集1 的部份不做处理，不符合的剩余部份才进行转换<br>-d：删除指令字符<br>cat testfile |tr a-z A-Z<br>转换大小写</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>cat 1.txt | grep aaa<br>显示1.txt中有aaa的行<br>grep -rn test ./<br>查找当前目录下的文件中有test的行，显示行号</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find . -name “my*” -ls<br>搜索当前目录中，所有文件名以my开头的文件，并显示详细信息</p><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>locate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。<br>locate -i ~/m<br>搜索用户主目录下，所有以m开头的文件，并且忽略大小写</p><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>在环境变量中搜索，返回第一个，可以看是否存在命令，用的是哪一个</p><h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>查找二进制文件（-b），man说明文件（-m），源代码文件（-s）</p><h2 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h2><p>获取指令简介<br>查看命令所在man帮助信息的目录<br>该命令在系统启动大约七十分钟后生成whatis数据库<br>可以用makewhatis立刻初始化数据库</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>chmod -R [ugoa][+-=][rwxX] example<br>-R 递归修改子目录权限<br>u 表示该文件的拥有者<br>g 表示与该文件的拥有者属于同一个组(group)的人<br>o 表示该组以外的人<br>a 表示所有人<br>+ 表示增加权限<br>- 表示取消权限<br>= 表示唯一设定权限<br>r 读取<br>w 写入<br>x 执行</p><p>或者chmod 744 example</p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>chown -R user[:group] example </p><p>-R 递归修改<br>修改文件所有权为user，group组</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>ps aux 显示所有进程</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>netstat -pantu 显示所有端口连接</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>查看网卡信息<br>ifconfig eth0 up/down<br>启动/关闭网卡<br>ifconfig eth0 127.0.0.1 up<br>改网卡IP</p><h2 id="iwconfig"><a href="#iwconfig" class="headerlink" title="iwconfig"></a>iwconfig</h2><p>查看网卡无线详细信息</p><h2 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h2><p>硬件变化日志</p><h2 id="macchanger"><a href="#macchanger" class="headerlink" title="macchanger"></a>macchanger</h2><p>修改网卡mac地址<br>macchanger -m E0:DC:FF:E1:E9:A1 wlan0</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>history查看命令历史<br>-c 清空命令历史<br>-d 删除一条指定命令<br>-w 将历史保存到指定文件中</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从这里开始</title>
      <link href="2020/11/27/hello-world/"/>
      <url>2020/11/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>hello world？</p>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
